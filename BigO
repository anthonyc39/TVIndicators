//@version=6
//Made by Anthony Colajezzi

indicator("Big O", overlay=true, max_boxes_count=500, max_lines_count=500)

// === LONG (Bull) SETTINGS ===
section_long = "LONG ALERT"
enableLong = input.bool(true, "Long Alerts", group=section_long)
bullTriangleColor = input.color(#4caf50, "Triangle Color", group=section_long)
brokenBearOpenLineColor = input.color(color.white, "Broken Line Color", group=section_long)
bullishFVGBoxColor = input.color(color.rgb(37, 153, 250, 64), "Bullish FVG Box Color", group=section_long)
bullFVGTradedColor = input.color(color.rgb(29, 173, 7, 64), "FVG Traded-Back-Into Color", group=section_long)
bullFVGBoxLength = input.int(400, "FVG Box Projection (1 - 400 Bars)", minval=1, maxval=400, group=section_long)
bullFVG50MidColor = input.color(color.white, "FVG 50% Retracement Line Color", group=section_long)

// === SHORT (Bear) SETTINGS ===
section_short = "SHORT ALERT"
enableShort = input.bool(true, "Short Alerts", group=section_short)
bearTriangleColor = input.color(#e57373, "Triangle Color", group=section_short)
brokenBullOpenLineColor = input.color(color.white, "Broken Line Color", group=section_short)
bearishFVGBoxColor = input.color(color.rgb(242, 148, 27, 64), "Bearish FVG Box Color", group=section_short)
bearFVGTradedColor = input.color(color.rgb(242, 64, 27, 64), "FVG Traded-Back-Into Color", group=section_short)
bearFVGBoxLength = input.int(400, "FVG Box Projection (1 - 400 Bars)", minval=1, maxval=400, group=section_short)
bearFVG50MidColor = input.color(color.white, "FVG 50% Retracement Line Color", group=section_short)

// === NEW: FVG size filter ===
section_fvg_filter = "FVG Size Filter"
hideLargeFVGEnable = input.bool(false, "Enable 'Hide large FVGs' filter", group=section_fvg_filter)
maxFVGTicks = input.int(120, "Max FVG size plotted (ticks) ", minval=1, group=section_fvg_filter)

// === COMMON ===
input_in_status_line = input.bool(true, "Inputs in status line", inline="status")

// === SESSION SETTINGS ===
section_sessions = "TRADING SESSIONS"
enableSessions = input.bool(true, "Enable Session Boxes", group=section_sessions)
enableSessionLines = input.bool(true, "Enable Session High/Low Lines", group=section_sessions)

// Individual session enables
enableAsiaSession = input.bool(true, "Asia Session (6PM-2AM)", group=section_sessions)
asiaSessionColor = input.color(color.new(color.teal, 90), "Asia Color", group=section_sessions)
asiaLineColor = input.color(color.teal, "Asia Line Color", group=section_sessions)

enableLondonSession = input.bool(true, "London Session (2AM-7AM)", group=section_sessions)
londonSessionColor = input.color(color.new(color.orange, 90), "London Color", group=section_sessions)
londonLineColor = input.color(color.orange, "London Line Color", group=section_sessions)

enableNYAMSession = input.bool(true, "NY AM Session (7AM-12PM)", group=section_sessions)
nyamSessionColor = input.color(color.new(color.purple, 90), "NY AM Color", group=section_sessions)
nyamLineColor = input.color(color.purple, "NY AM Line Color", group=section_sessions)

enableLunchSession = input.bool(true, "Lunch Session (12PM-1PM)", group=section_sessions)
lunchSessionColor = input.color(color.new(color.yellow, 90), "Lunch Color", group=section_sessions)
lunchLineColor = input.color(color.yellow, "Lunch Line Color", group=section_sessions)

enableNYPMSession = input.bool(true, "NY PM Session (1PM-5PM)", group=section_sessions)
nypmSessionColor = input.color(color.new(color.purple, 90), "NY PM Color", group=section_sessions)
nypmLineColor = input.color(color.purple, "NY PM Line Color", group=section_sessions)

sessionLineWidth = input.int(2, "Session Line Width", minval=1, maxval=5, group=section_sessions)
sessionLineSnapBars = input.int(30, "Bars After Invalidation", minval=1, maxval=100, group=section_sessions)

// ========== SESSION DETECTION & TRACKING ==========

// Session time detection (EST timezone)
est_time = hour(time, "America/New_York") * 100 + minute(time, "America/New_York")

// Determine current session
is_asia_session = (est_time >= 1800) or (est_time < 200)
is_london_session = (est_time >= 200) and (est_time < 700)
is_nyam_session = (est_time >= 700) and (est_time < 1200)
is_lunch_session = (est_time >= 1200) and (est_time < 1300)
is_nypm_session = (est_time >= 1300) and (est_time < 1700)

// Session state tracking
var string currentSession = na
var string lastSession = na
var bool sessionChanged = false

// Detect session changes
string detectedSession = na
if is_asia_session and enableAsiaSession
    detectedSession := "ASIA"
else if is_london_session and enableLondonSession
    detectedSession := "LONDON"
else if is_nyam_session and enableNYAMSession
    detectedSession := "NYAM"
else if is_lunch_session and enableLunchSession
    detectedSession := "LUNCH"
else if is_nypm_session and enableNYPMSession
    detectedSession := "NYPM"

if detectedSession != currentSession
    lastSession := currentSession
    currentSession := detectedSession
    sessionChanged := true
else
    sessionChanged := false

// Session high/low tracking
var float asiaHigh = na, var float asiaLow = na, var int asiaStartBar = na
var float londonHigh = na, var float londonLow = na, var int londonStartBar = na
var float nyamHigh = na, var float nyamLow = na, var int nyamStartBar = na
var float lunchHigh = na, var float lunchLow = na, var int lunchStartBar = na
var float nypmHigh = na, var float nypmLow = na, var int nypmStartBar = na

// Session line tracking
var line asiaHighLine = na, var line asiaLowLine = na
var line londonHighLine = na, var line londonLowLine = na
var line nyamHighLine = na, var line nyamLowLine = na
var line lunchHighLine = na, var line lunchLowLine = na
var line nypmHighLine = na, var line nypmLowLine = na

// Invalidation tracking (bar index when invalidated + N bars)
var int asiaHighInvalidBar = na, var int asiaLowInvalidBar = na
var int londonHighInvalidBar = na, var int londonLowInvalidBar = na
var int nyamHighInvalidBar = na, var int nyamLowInvalidBar = na
var int lunchHighInvalidBar = na, var int lunchLowInvalidBar = na
var int nypmHighInvalidBar = na, var int nypmLowInvalidBar = na

// Session box tracking
var box asiaBox = na
var box londonBox = na
var box nyamBox = na
var box lunchBox = na
var box nypmBox = na

// ========== STATE MACHINES & STORAGE ==========

// --- Bullish FVG System ---
var int bullState_idle = 0, bullState_bear_run = 1, bullState_bear_log = 2, bullState_bull_reversal = 3
var int bullState = bullState_idle
var int bearStreak = 0
var int lastBearStreak = 0
var float[] bearOpens = array.new_float()
var int[] bearBarIndexes = array.new_int()

// bull FVG storage
var box[] bullFVGBoxes = array.new_box()
var float[] bullFVGHighs = array.new_float()
var float[] bullFVGLows = array.new_float()
var line[] bullFVG50Lines = array.new_line()
var int[] bullFVGIds = array.new_int()
var bool[] bullFVGTraded = array.new_bool()
var int[] bullFVGStartBarIdx = array.new_int()

var bool bullCanPlotFVG = false
var int bullReversalId = 0
var line bullLastLine = na
var label bullLastTriangle = na
var bool bullReversalComplete = false
var int bullPrevMaxIdx = na
var bool bullPendingSignalFVG = false
var bool bullBrokeFirstBearOpen = false
var bool bullWaitingAfterFirstBreak = false
var bool bullJustEnteredIdle = false
var bool bullJustEnteredIdleHadSignal = false
var int bullReversalCompletedOn = na

// --- FIXED / MISSING declarations for bull side
var int bullReversalEndedOn = na
var int bullBarsAfterReversal = 0
var bool bullJustConfirmedReversal = false

// pending-signal arrays for bull side
var int[] bullSignalBars = array.new_int()
var int[] bullSignalReversalIds = array.new_int()
var bool[] bullSignalFVGCreated = array.new_bool()

// Arrays to track all drawn lines/triangles (declare once, push object ids into them)
var line[] bullAllLines = array.new_line()
var label[] bullAllTriangles = array.new_label()

// --- Bearish FVG System ---
var int bearState_idle = 0, bearState_bull_run = 1, bearState_bull_log = 2, bearState_bear_reversal = 3
var int bearState = bearState_idle
var int bullStreak = 0
var int lastBullStreak = 0
var float[] bullOpens = array.new_float()
var int[] bullBarIndexes = array.new_int()

// bear FVG storage
var box[] bearFVGBoxes = array.new_box()
var float[] bearFVGHighs = array.new_float()
var float[] bearFVGLows = array.new_float()
var line[] bearFVG50Lines = array.new_line()
var int[] bearFVGIds = array.new_int()
var bool[] bearFVGTraded = array.new_bool()
var int[] bearFVGStartBarIdx = array.new_int()

var bool bearCanPlotFVG = false
var int bearReversalId = 0
var line bearLastLine = na
var label bearLastTriangle = na
var bool bearReversalComplete = false
var int bearPrevMinIdx = na
var bool bearPendingSignalFVG = false
var bool bearBrokeFirstBullOpen = false
var bool bearWaitingAfterFirstBreak = false
var bool bearJustEnteredIdle = false
var bool bearJustEnteredIdleHadSignal = false
var int bearReversalCompletedOn = na

// --- FIXED / MISSING declarations for bear side
var int bearReversalEndedOn = na
var int bearBarsAfterReversal = 0
var bool bearJustConfirmedReversal = false

// pending-signal arrays for bear side
var int[] bearSignalBars = array.new_int()
var int[] bearSignalReversalIds = array.new_int()
var bool[] bearSignalFVGCreated = array.new_bool()

// Arrays to track all drawn bear lines/triangles (declare once)
var line[] bearAllLines = array.new_line()
var label[] bearAllTriangles = array.new_label()

// --- helpers: candle classification
is_bear = close < open
is_bull = close > open
is_doji = open == close

// Helper: compute FVG size in ticks (safe)
fvg_size_ticks(_top, _bottom) =>
    tick_size = syminfo.mintick
    tick_size := tick_size == 0 ? 1e-10 : tick_size
    math.round(math.abs(_top - _bottom) / tick_size)

// ---------------------
// MAIN LOGIC
// ---------------------

// === LONG (bull) state machine / detection
if enableLong
    if not is_doji
        if bullWaitingAfterFirstBreak
            bullWaitingAfterFirstBreak := false
            if is_bear
                // start a bear run
                bullState := bullState_bear_run
                bearStreak := 1
                array.clear(bearOpens)
                array.clear(bearBarIndexes)
                bullLastLine := na
                bullLastTriangle := na
                bullReversalComplete := false
                bullReversalCompletedOn := na
                array.push(bearOpens, open)
                array.push(bearBarIndexes, bar_index)
                bullCanPlotFVG := false
                bullPendingSignalFVG := false
                bullPrevMaxIdx := na
                bullJustEnteredIdle := false
                bullJustEnteredIdleHadSignal := false
            else if is_bull
                // keep reversal state so follow-up can be re-evaluated
                bullState := bullState_bull_reversal
                // keep arrays & prev index intact
                bullJustEnteredIdle := false
        else
            if is_bear
                if bullState == bullState_bull_reversal
                    if na(bullPrevMaxIdx)
                        int j = 0
                        while j < array.size(bullFVGIds)
                            if array.get(bullFVGIds, j) == bullReversalId
                                box.delete(array.get(bullFVGBoxes, j))
                                line.delete(array.get(bullFVG50Lines, j))
                                array.remove(bullFVGBoxes, j)
                                array.remove(bullFVGHighs, j)
                                array.remove(bullFVGLows, j)
                                array.remove(bullFVG50Lines, j)
                                array.remove(bullFVGIds, j)
                                array.remove(bullFVGTraded, j)
                                array.remove(bullFVGStartBarIdx, j)
                            else
                                j += 1
                if bullState == bullState_idle or bullState == bullState_bull_reversal
                    bullState := bullState_bear_run
                    bearStreak := 1
                    array.clear(bearOpens)
                    array.clear(bearBarIndexes)
                    bullLastLine := na
                    bullLastTriangle := na
                    bullReversalComplete := false
                    bullReversalCompletedOn := na
                    array.push(bearOpens, open)
                    array.push(bearBarIndexes, bar_index)
                    bullCanPlotFVG := false
                    bullPendingSignalFVG := false
                    bullPrevMaxIdx := na
                    bullJustEnteredIdle := false
                    bullJustEnteredIdleHadSignal := false
                else
                    bearStreak += 1
                    array.push(bearOpens, open)
                    array.push(bearBarIndexes, bar_index)
            else
                if bearStreak > 0 and bullState == bullState_bear_run
                    lastBearStreak := bearStreak
                    bullState := bullState_bull_reversal
                    bullCanPlotFVG := lastBearStreak >= 3
                    bullReversalId += 1
                bearStreak := 0

    // triple-negation block kept (rare)
    if bullState == bullState_bull_reversal and not is_bull and not is_bear and not is_doji
        bullReversalEndedOn := bar_index
        bullBarsAfterReversal := 0

    if (bullState == bullState_bear_run or bullState == bullState_idle) and not na(bullReversalEndedOn)
        bullBarsAfterReversal += 1
        if bullBarsAfterReversal > 1
            bullCanPlotFVG := false

    bullAboveCount = 0
    var int[] brokenBearIdxs = na
    if na(brokenBearIdxs)
        brokenBearIdxs := array.new_int()
    else
        array.clear(brokenBearIdxs)

    // Equality counts for initial detection (>=).
    // Redraw/move allowed only if reversal not already completed OR if this bar is the bar that completed reversal.
    if bullState == bullState_bull_reversal and is_bull and not is_doji and array.size(bearOpens) > 0 and array.size(bearBarIndexes) > 0 and (not bullReversalComplete or bar_index == bullReversalCompletedOn)
        for i = 0 to array.size(bearOpens)-1
            if close >= array.get(bearOpens, i)
                bullAboveCount += 1
                array.push(brokenBearIdxs, i)
        if bullAboveCount >= 3
            float max_open = na
            int max_idx = na
            for j = 0 to array.size(brokenBearIdxs)-1
                idx = array.get(brokenBearIdxs, j)
                if idx < array.size(bearBarIndexes) and idx < array.size(bearOpens)
                    this_open = array.get(bearOpens, idx)
                    if na(max_open) or this_open > max_open
                        max_open := this_open
                        max_idx := idx
            // Only mark the reversal "complete" when the CLOSE strictly exceeds the first open.
            if not na(max_idx) and max_idx == 0 and close > array.get(bearOpens, 0)
                bullReversalComplete := true
                bullReversalCompletedOn := bar_index
            // Allow redraw/move when found index is same or earlier
            if not na(max_idx) and (na(bullPrevMaxIdx) or max_idx <= bullPrevMaxIdx)
                if not na(bullLastLine)
                    line.delete(bullLastLine)
                    bullLastLine := na
                if not na(bullLastTriangle)
                    label.delete(bullLastTriangle)
                    bullLastTriangle := na
                start_bar = array.get(bearBarIndexes, max_idx)
                y = array.get(bearOpens, max_idx)
                // Determine if this signal was caused by EQUALITY (close == the run open)
                isEqualitySignal = close == array.get(bearOpens, max_idx)
                lineColor = isEqualitySignal ? color.yellow : brokenBearOpenLineColor
                triColor = isEqualitySignal ? color.yellow : bullTriangleColor
                bullLastLine := line.new(start_bar, y, bar_index, y, color=lineColor, width=2)
                bullLastTriangle := label.new(bar_index, high, "", style=label.style_triangledown, color=triColor, size=size.small, yloc=yloc.abovebar)
                // push into the declared arrays (fixed: don't assign inside push)
                array.push(bullAllLines, bullLastLine)
                array.push(bullAllTriangles, bullLastTriangle)
                // register pending signal for FVG check (immediate next bar)
                array.push(bullSignalBars, bar_index)
                array.push(bullSignalReversalIds, bullReversalId)
                array.push(bullSignalFVGCreated, false)
                bullPrevMaxIdx := max_idx
                bullJustConfirmedReversal := true
                bullPendingSignalFVG := true

        if array.size(bearOpens) > 0 and close >= array.get(bearOpens, 0)
            bullBrokeFirstBearOpen := true
            bullWaitingAfterFirstBreak := true
        else
            bullBrokeFirstBearOpen := false

    // FVG creation - only allow if reversal not complete OR if this is the exact bar that completed reversal
    if bullCanPlotFVG and bullState == bullState_bull_reversal and bar_index > 1 and (not bullReversalComplete or bar_index == bullReversalCompletedOn)
        rightLow   = low
        leftHigh = high[2]
        if rightLow > leftHigh
            fvgTop    = math.max(leftHigh, rightLow)
            fvgBottom = math.min(leftHigh, rightLow)
            // NEW: compute FVG size in ticks and optionally skip plotting if too large
            fvgTicks = fvg_size_ticks(fvgTop, fvgBottom)
            shouldPlot = not hideLargeFVGEnable or (fvgTicks <= maxFVGTicks)
            if shouldPlot
                fvg_box = box.new(bar_index-2, fvgTop, bar_index-2 + bullFVGBoxLength, fvgBottom, border_width=0, bgcolor=bullishFVGBoxColor)
                fvgMid = (fvgTop + fvgBottom) / 2
                fvg_mid_line = line.new(bar_index-2, fvgMid, bar_index-2 + bullFVGBoxLength, fvgMid, color=bullFVG50MidColor, width=1)
                array.push(bullFVGBoxes, fvg_box)
                array.push(bullFVGHighs, fvgTop)
                array.push(bullFVGLows, fvgBottom)
                array.push(bullFVG50Lines, fvg_mid_line)
                array.push(bullFVGIds, bullReversalId)
                array.push(bullFVGTraded, false)
                array.push(bullFVGStartBarIdx, bar_index)

    // The alternate FVG creation path that triggers when entering idle / pending
    if (bullJustEnteredIdle and not is_doji and bar_index > 1 and bullJustEnteredIdleHadSignal) or (bearStreak == 1 and bullPendingSignalFVG and not is_doji and bar_index > 1 and (not bullReversalComplete or bar_index == bullReversalCompletedOn))
        rightLow   = low[0]
        leftHigh = high[2]
        fvgTop    = math.max(leftHigh, rightLow)
        fvgBottom = math.min(leftHigh, rightLow)
        if rightLow > leftHigh
            fvgTicks2 = fvg_size_ticks(fvgTop, fvgBottom)
            shouldPlot2 = not hideLargeFVGEnable or (fvgTicks2 <= maxFVGTicks)
            if shouldPlot2
                fvg_box = box.new(bar_index-2, fvgTop, bar_index-2 + bullFVGBoxLength, fvgBottom, border_width=0, bgcolor=bullishFVGBoxColor)
                fvgMid = (fvgTop + fvgBottom) / 2
                fvg_mid_line = line.new(bar_index-2, fvgMid, bar_index-2 + bullFVGBoxLength, fvgMid, color=bullFVG50MidColor, width=1)
                array.push(bullFVGBoxes, fvg_box)
                array.push(bullFVGHighs, fvgTop)
                array.push(bullFVGLows, fvgBottom)
                array.push(bullFVG50Lines, fvg_mid_line)
                array.push(bullFVGIds, bullReversalId)
                array.push(bullFVGTraded, false)
                array.push(bullFVGStartBarIdx, bar_index)
        bullPendingSignalFVG := false
        bullJustEnteredIdle := false
        bullJustEnteredIdleHadSignal := false

    if array.size(bullFVGBoxes) > 0
        int i = 0
        while i < array.size(bullFVGBoxes)
            traded = array.get(bullFVGTraded, i)
            high_ = array.get(bullFVGHighs, i)
            low_ = array.get(bullFVGLows, i)
            fvgStartIdx = array.get(bullFVGStartBarIdx, i)
            isTraded = (high >= low_ and low <= high_) and not traded and (bar_index > fvgStartIdx)
            invalidate = close < low_
            if invalidate
                box.delete(array.get(bullFVGBoxes, i))
                line.delete(array.get(bullFVG50Lines, i))
                array.remove(bullFVGBoxes, i)
                array.remove(bullFVGHighs, i)
                array.remove(bullFVGLows, i)
                array.remove(bullFVG50Lines, i)
                array.remove(bullFVGIds, i)
                array.remove(bullFVGTraded, i)
                array.remove(bullFVGStartBarIdx, i)
            else
                if isTraded
                    box.set_bgcolor(array.get(bullFVGBoxes, i), bullFVGTradedColor)
                    array.set(bullFVGTraded, i, true)
                box.set_right(array.get(bullFVGBoxes, i), bar_index + bullFVGBoxLength)
                line.set_x2(array.get(bullFVG50Lines, i), bar_index + bullFVGBoxLength)
                i += 1

// === SHORT (bear) state machine / detection (mirror of bull)
if enableShort
    if not is_doji
        if bearWaitingAfterFirstBreak
            bearWaitingAfterFirstBreak := false
            if is_bull
                bearState := bearState_bull_run
                bullStreak := 1
                array.clear(bullOpens)
                array.clear(bullBarIndexes)
                bearLastLine := na
                bearLastTriangle := na
                bearReversalComplete := false
                bearReversalCompletedOn := na
                array.push(bullOpens, open)
                array.push(bullBarIndexes, bar_index)
                bearCanPlotFVG := false
                bearPendingSignalFVG := false
                bearPrevMinIdx := na
                bearJustEnteredIdle := false
                bearJustEnteredIdleHadSignal := false
            else if is_bear
                // keep reversal state so follow-up can be re-evaluated
                bearState := bearState_bear_reversal
                bearReversalEndedOn := na
        else
            if is_bull
                if bearState == bearState_bear_reversal
                    if na(bearPrevMinIdx)
                        int j = 0
                        while j < array.size(bearFVGIds)
                            if array.get(bearFVGIds, j) == bearReversalId
                                box.delete(array.get(bearFVGBoxes, j))
                                line.delete(array.get(bearFVG50Lines, j))
                                array.remove(bearFVGBoxes, j)
                                array.remove(bearFVGHighs, j)
                                array.remove(bearFVGLows, j)
                                array.remove(bearFVG50Lines, j)
                                array.remove(bearFVGIds, j)
                                array.remove(bearFVGTraded, j)
                                array.remove(bearFVGStartBarIdx, j)
                            else
                                j += 1
                if bearState == bearState_idle or bearState == bearState_bear_reversal
                    bearState := bearState_bull_run
                    bullStreak := 1
                    array.clear(bullOpens)
                    array.clear(bullBarIndexes)
                    bearLastLine := na
                    bearLastTriangle := na
                    bearReversalComplete := false
                    bearReversalCompletedOn := na
                    array.push(bullOpens, open)
                    array.push(bullBarIndexes, bar_index)
                    bearCanPlotFVG := false
                    bearPendingSignalFVG := false
                    bearPrevMinIdx := na
                    bearJustEnteredIdle := false
                    bearJustEnteredIdleHadSignal := false
                else
                    bullStreak += 1
                    array.push(bullOpens, open)
                    array.push(bullBarIndexes, bar_index)
            else
                if bullStreak > 0 and bearState == bearState_bull_run
                    lastBullStreak := bullStreak
                    bearState := bearState_bear_reversal
                    bearCanPlotFVG := lastBullStreak >= 3
                    bearReversalId += 1
                bullStreak := 0

    // triple-negation kept
    if bearState == bearState_bear_reversal and not is_bear and not is_bull and not is_doji
        bearReversalEndedOn := bar_index
        bearBarsAfterReversal := 0

    if (bearState == bearState_bull_run or bearState == bearState_idle) and not na(bearReversalEndedOn)
        bearBarsAfterReversal += 1
        if bearBarsAfterReversal > 1
            bearCanPlotFVG := false

    bearBelowCount = 0
    var int[] brokenBullIdxs = na
    if na(brokenBullIdxs)
        brokenBullIdxs := array.new_int()
    else
        array.clear(brokenBullIdxs)

    // Equality counts for initial detection (<=).
    // Redraw/move allowed only if reversal not already completed OR if this bar is the bar that completed reversal.
    if bearState == bearState_bear_reversal and is_bear and not is_doji and array.size(bullOpens) > 0 and array.size(bullBarIndexes) > 0 and (not bearReversalComplete or bar_index == bearReversalCompletedOn)
        for i = 0 to array.size(bullOpens)-1
            if close <= array.get(bullOpens, i)
                bearBelowCount += 1
                array.push(brokenBullIdxs, i)
        if bearBelowCount >= 3
            float min_open = na
            int min_idx = na
            for j = 0 to array.size(brokenBullIdxs)-1
                idx = array.get(brokenBullIdxs, j)
                if idx < array.size(bullBarIndexes) and idx < array.size(bullOpens)
                    this_open = array.get(bullOpens, idx)
                    if na(min_open) or this_open < min_open
                        min_open := this_open
                        min_idx := idx
            // Only mark reversal complete when CLOSE strictly below the first bull open
            if not na(min_idx) and min_idx == 0 and close < array.get(bullOpens, 0)
                bearReversalComplete := true
                bearReversalCompletedOn := bar_index
            // Allow redraw/move when the found min_idx is the same or earlier
            if not na(min_idx) and (na(bearPrevMinIdx) or min_idx <= bearPrevMinIdx)
                if not na(bearLastLine)
                    line.delete(bearLastLine)
                    bearLastLine := na
                if not na(bearLastTriangle)
                    label.delete(bearLastTriangle)
                    bearLastTriangle := na
                start_bar = array.get(bullBarIndexes, min_idx)
                y = array.get(bullOpens, min_idx)
                // Determine if this signal was caused by EQUALITY (close == the run open)
                isEqualitySignal_bear = close == array.get(bullOpens, min_idx)
                lineColor_bear = isEqualitySignal_bear ? color.yellow : brokenBullOpenLineColor
                triColor_bear = isEqualitySignal_bear ? color.yellow : bearTriangleColor
                bearLastLine := line.new(start_bar, y, bar_index, y, color=lineColor_bear, width=2)
                bearLastTriangle := label.new(bar_index, low, "", style=label.style_triangleup, color=triColor_bear, size=size.small, yloc=yloc.belowbar)
                // push into the declared arrays (fixed)
                array.push(bearAllLines, bearLastLine)
                array.push(bearAllTriangles, bearLastTriangle)
                array.push(bearSignalBars, bar_index)
                array.push(bearSignalReversalIds, bearReversalId)
                array.push(bearSignalFVGCreated, false)
                bearPrevMinIdx := min_idx
                bearJustConfirmedReversal := true
                bearPendingSignalFVG := true

        if array.size(bullOpens) > 0 and close <= array.get(bullOpens, 0)
            bearBrokeFirstBullOpen := true
            bearWaitingAfterFirstBreak := true
        else
            bearBrokeFirstBullOpen := false

    // FVG creation - only allow if reversal not complete OR if this is the exact bar that completed reversal
    if bearCanPlotFVG and bearState == bearState_bear_reversal and bar_index > 1 and (not bearReversalComplete or bar_index == bearReversalCompletedOn)
        leftLow   = low[2]
        rightHigh = high
        if rightHigh < leftLow
            fvgTop    = math.max(leftLow, rightHigh)
            fvgBottom = math.min(leftLow, rightHigh)
            fvgTicks_b = fvg_size_ticks(fvgTop, fvgBottom)
            shouldPlot_b = not hideLargeFVGEnable or (fvgTicks_b <= maxFVGTicks)
            if shouldPlot_b
                fvg_box = box.new(bar_index-2, fvgTop, bar_index-2 + bearFVGBoxLength, fvgBottom, border_width=0, bgcolor=bearishFVGBoxColor)
                fvgMid = (fvgTop + fvgBottom) / 2
                fvg_mid_line = line.new(bar_index-2, fvgMid, bar_index-2 + bearFVGBoxLength, fvgMid, color=bearFVG50MidColor, width=1)
                array.push(bearFVGBoxes, fvg_box)
                array.push(bearFVGHighs, fvgTop)
                array.push(bearFVGLows, fvgBottom)
                array.push(bearFVG50Lines, fvg_mid_line)
                array.push(bearFVGIds, bearReversalId)
                array.push(bearFVGTraded, false)
                array.push(bearFVGStartBarIdx, bar_index)

    // The alternate FVG creation path that triggers when entering idle / pending
    if (bearJustEnteredIdle and not is_doji and bar_index > 1 and bearJustEnteredIdleHadSignal) or (bullStreak == 1 and bearPendingSignalFVG and not is_doji and bar_index > 1 and (not bearReversalComplete or bar_index == bearReversalCompletedOn))
        leftLow   = low[2]
        rightHigh = high[0]
        fvgTop    = math.max(leftLow, rightHigh)
        fvgBottom = math.min(leftLow, rightHigh)
        if rightHigh < leftLow
            fvgTicks_b2 = fvg_size_ticks(fvgTop, fvgBottom)
            shouldPlot_b2 = not hideLargeFVGEnable or (fvgTicks_b2 <= maxFVGTicks)
            if shouldPlot_b2
                fvg_box = box.new(bar_index-2, fvgTop, bar_index-2 + bearFVGBoxLength, fvgBottom, border_width=0, bgcolor=bearishFVGBoxColor)
                fvgMid = (fvgTop + fvgBottom) / 2
                fvg_mid_line = line.new(bar_index-2, fvgMid, bar_index-2 + bearFVGBoxLength, fvgMid, color=bearFVG50MidColor, width=1)
                array.push(bearFVGBoxes, fvg_box)
                array.push(bearFVGHighs, fvgTop)
                array.push(bearFVGLows, fvgBottom)
                array.push(bearFVG50Lines, fvg_mid_line)
                array.push(bearFVGIds, bearReversalId)
                array.push(bearFVGTraded, false)
                array.push(bearFVGStartBarIdx, bar_index)
        bearPendingSignalFVG := false
        bearJustEnteredIdle := false
        bearJustEnteredIdleHadSignal := false

    if array.size(bearFVGBoxes) > 0
        int i = 0
        while i < array.size(bearFVGBoxes)
            traded = array.get(bearFVGTraded, i)
            high_ = array.get(bearFVGHighs, i)
            low_ = array.get(bearFVGLows, i)
            fvgStartIdx = array.get(bearFVGStartBarIdx, i)
            isTraded = (low <= high_ and high >= low_) and not traded and (bar_index > fvgStartIdx)
            invalidate = close > high_
            if invalidate
                box.delete(array.get(bearFVGBoxes, i))
                line.delete(array.get(bearFVG50Lines, i))
                array.remove(bearFVGBoxes, i)
                array.remove(bearFVGHighs, i)
                array.remove(bearFVGLows, i)
                array.remove(bearFVG50Lines, i)
                array.remove(bearFVGIds, i)
                array.remove(bearFVGTraded, i)
                array.remove(bearFVGStartBarIdx, i)
            else
                if isTraded
                    box.set_bgcolor(array.get(bearFVGBoxes, i), bearFVGTradedColor)
                    array.set(bearFVGTraded, i, true)
                box.set_right(array.get(bearFVGBoxes, i), bar_index + bearFVGBoxLength)
                line.set_x2(array.get(bearFVG50Lines, i), bar_index + bearFVGBoxLength)
                i += 1

// =======================
// Pending-signal FVG checks (immediate next bar only)
// =======================

// Bear-side: evaluate pending bear signals only on immediate next bar (sigBar + 1)
if enableShort and array.size(bearSignalBars) > 0
    int bi = 0
    while bi < array.size(bearSignalBars)
        sigBar = array.get(bearSignalBars, bi)
        sigRevId = array.get(bearSignalReversalIds, bi)
        created = array.get(bearSignalFVGCreated, bi)
        if not created
            if bar_index == sigBar + 1
                leftLow = low[2]
                rightHigh = high
                if rightHigh < leftLow
                    fvgTop = math.max(leftLow, rightHigh)
                    fvgBottom = math.min(leftLow, rightHigh)
                    fvgTicksP = fvg_size_ticks(fvgTop, fvgBottom)
                    shouldPlotP = not hideLargeFVGEnable or (fvgTicksP <= maxFVGTicks)
                    if shouldPlotP
                        box_start = sigBar - 1
                        fvg_box = box.new(box_start, fvgTop, box_start + bearFVGBoxLength, fvgBottom, border_width=0, bgcolor=bearishFVGBoxColor)
                        fvgMid = (fvgTop + fvgBottom) / 2
                        fvg_mid_line = line.new(box_start, fvgMid, box_start + bearFVGBoxLength, fvgMid, color=bearFVG50MidColor, width=1)
                        array.push(bearFVGBoxes, fvg_box)
                        array.push(bearFVGHighs, fvgTop)
                        array.push(bearFVGLows, fvgBottom)
                        array.push(bearFVG50Lines, fvg_mid_line)
                        array.push(bearFVGIds, sigRevId)
                        array.push(bearFVGTraded, false)
                        array.push(bearFVGStartBarIdx, bar_index)
                        array.set(bearSignalFVGCreated, bi, true)
                    else
                        array.set(bearSignalFVGCreated, bi, true)
                else
                    array.set(bearSignalFVGCreated, bi, true)
            else if bar_index > sigBar + 1
                array.set(bearSignalFVGCreated, bi, true)
        bi += 1

// Bull-side: evaluate pending bull signals only on immediate next bar (sigBar + 1)
if enableLong and array.size(bullSignalBars) > 0
    int bi2 = 0
    while bi2 < array.size(bullSignalBars)
        sigBar2 = array.get(bullSignalBars, bi2)
        sigRevId2 = array.get(bullSignalReversalIds, bi2)
        created2 = array.get(bullSignalFVGCreated, bi2)
        if not created2
            if bar_index == sigBar2 + 1
                leftHigh = high[2]
                rightLow = low
                if rightLow > leftHigh
                    fvgTop2 = math.max(leftHigh, rightLow)
                    fvgBottom2 = math.min(leftHigh, rightLow)
                    fvgTicksP2 = fvg_size_ticks(fvgTop2, fvgBottom2)
                    shouldPlotP2 = not hideLargeFVGEnable or (fvgTicksP2 <= maxFVGTicks)
                    if shouldPlotP2
                        box_start2 = sigBar2 - 1
                        fvg_box2 = box.new(box_start2, fvgTop2, box_start2 + bullFVGBoxLength, fvgBottom2, border_width=0, bgcolor=bullishFVGBoxColor)
                        fvgMid2 = (fvgTop2 + fvgBottom2) / 2
                        fvg_mid_line2 = line.new(box_start2, fvgMid2, box_start2 + bullFVGBoxLength, fvgMid2, color=bullFVG50MidColor, width=1)
                        array.push(bullFVGBoxes, fvg_box2)
                        array.push(bullFVGHighs, fvgTop2)
                        array.push(bullFVGLows, fvgBottom2)
                        array.push(bullFVG50Lines, fvg_mid_line2)
                        array.push(bullFVGIds, sigRevId2)
                        array.push(bullFVGTraded, false)
                        array.push(bullFVGStartBarIdx, bar_index)
                        array.set(bullSignalFVGCreated, bi2, true)
                    else
                        array.set(bullSignalFVGCreated, bi2, true)
                else
                    array.set(bullSignalFVGCreated, bi2, true)
            else if bar_index > sigBar2 + 1
                array.set(bullSignalFVGCreated, bi2, true)
        bi2 += 1

// ========== SESSION BOX & HIGH/LOW LINE LOGIC ==========

if enableSessions
    // Update session high/low and draw boxes
    if not na(currentSession)
        if currentSession == "ASIA"
            if sessionChanged or na(asiaHigh)
                asiaHigh := high
                asiaLow := low
                asiaStartBar := bar_index
                // Create new session box
                if not na(asiaBox)
                    box.delete(asiaBox)
                asiaBox := box.new(bar_index, high, bar_index, low, border_width=0, bgcolor=asiaSessionColor)
            else
                // Update session high/low
                asiaHigh := math.max(asiaHigh, high)
                asiaLow := math.min(asiaLow, low)
                // Extend box
                box.set_right(asiaBox, bar_index)
                box.set_top(asiaBox, asiaHigh)
                box.set_bottom(asiaBox, asiaLow)
        else if currentSession == "LONDON"
            if sessionChanged or na(londonHigh)
                londonHigh := high
                londonLow := low
                londonStartBar := bar_index
                if not na(londonBox)
                    box.delete(londonBox)
                londonBox := box.new(bar_index, high, bar_index, low, border_width=0, bgcolor=londonSessionColor)
            else
                londonHigh := math.max(londonHigh, high)
                londonLow := math.min(londonLow, low)
                box.set_right(londonBox, bar_index)
                box.set_top(londonBox, londonHigh)
                box.set_bottom(londonBox, londonLow)
        else if currentSession == "NYAM"
            if sessionChanged or na(nyamHigh)
                nyamHigh := high
                nyamLow := low
                nyamStartBar := bar_index
                if not na(nyamBox)
                    box.delete(nyamBox)
                nyamBox := box.new(bar_index, high, bar_index, low, border_width=0, bgcolor=nyamSessionColor)
            else
                nyamHigh := math.max(nyamHigh, high)
                nyamLow := math.min(nyamLow, low)
                box.set_right(nyamBox, bar_index)
                box.set_top(nyamBox, nyamHigh)
                box.set_bottom(nyamBox, nyamLow)
        else if currentSession == "LUNCH"
            if sessionChanged or na(lunchHigh)
                lunchHigh := high
                lunchLow := low
                lunchStartBar := bar_index
                if not na(lunchBox)
                    box.delete(lunchBox)
                lunchBox := box.new(bar_index, high, bar_index, low, border_width=0, bgcolor=lunchSessionColor)
            else
                lunchHigh := math.max(lunchHigh, high)
                lunchLow := math.min(lunchLow, low)
                box.set_right(lunchBox, bar_index)
                box.set_top(lunchBox, lunchHigh)
                box.set_bottom(lunchBox, lunchLow)
        else if currentSession == "NYPM"
            if sessionChanged or na(nypmHigh)
                nypmHigh := high
                nypmLow := low
                nypmStartBar := bar_index
                if not na(nypmBox)
                    box.delete(nypmBox)
                nypmBox := box.new(bar_index, high, bar_index, low, border_width=0, bgcolor=nypmSessionColor)
            else
                nypmHigh := math.max(nypmHigh, high)
                nypmLow := math.min(nypmLow, low)
                box.set_right(nypmBox, bar_index)
                box.set_top(nypmBox, nypmHigh)
                box.set_bottom(nypmBox, nypmLow)

if enableSessionLines
    // Session change: create new lines for previous session
    if sessionChanged and not na(lastSession)
        if lastSession == "ASIA" and not na(asiaHigh) and not na(asiaLow)
            if not na(asiaHighLine)
                line.delete(asiaHighLine)
            if not na(asiaLowLine)
                line.delete(asiaLowLine)
            asiaHighLine := line.new(asiaStartBar, asiaHigh, bar_index, asiaHigh, color=asiaLineColor, width=sessionLineWidth)
            asiaLowLine := line.new(asiaStartBar, asiaLow, bar_index, asiaLow, color=asiaLineColor, width=sessionLineWidth)
            asiaHighInvalidBar := na
            asiaLowInvalidBar := na
        else if lastSession == "LONDON" and not na(londonHigh) and not na(londonLow)
            if not na(londonHighLine)
                line.delete(londonHighLine)
            if not na(londonLowLine)
                line.delete(londonLowLine)
            londonHighLine := line.new(londonStartBar, londonHigh, bar_index, londonHigh, color=londonLineColor, width=sessionLineWidth)
            londonLowLine := line.new(londonStartBar, londonLow, bar_index, londonLow, color=londonLineColor, width=sessionLineWidth)
            londonHighInvalidBar := na
            londonLowInvalidBar := na
        else if lastSession == "NYAM" and not na(nyamHigh) and not na(nyamLow)
            if not na(nyamHighLine)
                line.delete(nyamHighLine)
            if not na(nyamLowLine)
                line.delete(nyamLowLine)
            nyamHighLine := line.new(nyamStartBar, nyamHigh, bar_index, nyamHigh, color=nyamLineColor, width=sessionLineWidth)
            nyamLowLine := line.new(nyamStartBar, nyamLow, bar_index, nyamLow, color=nyamLineColor, width=sessionLineWidth)
            nyamHighInvalidBar := na
            nyamLowInvalidBar := na
        else if lastSession == "LUNCH" and not na(lunchHigh) and not na(lunchLow)
            if not na(lunchHighLine)
                line.delete(lunchHighLine)
            if not na(lunchLowLine)
                line.delete(lunchLowLine)
            lunchHighLine := line.new(lunchStartBar, lunchHigh, bar_index, lunchHigh, color=lunchLineColor, width=sessionLineWidth)
            lunchLowLine := line.new(lunchStartBar, lunchLow, bar_index, lunchLow, color=lunchLineColor, width=sessionLineWidth)
            lunchHighInvalidBar := na
            lunchLowInvalidBar := na
        else if lastSession == "NYPM" and not na(nypmHigh) and not na(nypmLow)
            if not na(nypmHighLine)
                line.delete(nypmHighLine)
            if not na(nypmLowLine)
                line.delete(nypmLowLine)
            nypmHighLine := line.new(nypmStartBar, nypmHigh, bar_index, nypmHigh, color=nypmLineColor, width=sessionLineWidth)
            nypmLowLine := line.new(nypmStartBar, nypmLow, bar_index, nypmLow, color=nypmLineColor, width=sessionLineWidth)
            nypmHighInvalidBar := na
            nypmLowInvalidBar := na
    
    // Extend or invalidate lines based on price action
    // Asia lines
    if not na(asiaHighLine)
        if na(asiaHighInvalidBar)
            if high > asiaHigh
                asiaHighInvalidBar := bar_index
            else
                line.set_x2(asiaHighLine, bar_index)
        else if bar_index <= asiaHighInvalidBar + sessionLineSnapBars
            line.set_x2(asiaHighLine, bar_index)
        else
            line.delete(asiaHighLine)
            asiaHighLine := na
    
    if not na(asiaLowLine)
        if na(asiaLowInvalidBar)
            if low < asiaLow
                asiaLowInvalidBar := bar_index
            else
                line.set_x2(asiaLowLine, bar_index)
        else if bar_index <= asiaLowInvalidBar + sessionLineSnapBars
            line.set_x2(asiaLowLine, bar_index)
        else
            line.delete(asiaLowLine)
            asiaLowLine := na
    
    // London lines
    if not na(londonHighLine)
        if na(londonHighInvalidBar)
            if high > londonHigh
                londonHighInvalidBar := bar_index
            else
                line.set_x2(londonHighLine, bar_index)
        else if bar_index <= londonHighInvalidBar + sessionLineSnapBars
            line.set_x2(londonHighLine, bar_index)
        else
            line.delete(londonHighLine)
            londonHighLine := na
    
    if not na(londonLowLine)
        if na(londonLowInvalidBar)
            if low < londonLow
                londonLowInvalidBar := bar_index
            else
                line.set_x2(londonLowLine, bar_index)
        else if bar_index <= londonLowInvalidBar + sessionLineSnapBars
            line.set_x2(londonLowLine, bar_index)
        else
            line.delete(londonLowLine)
            londonLowLine := na
    
    // NY AM lines
    if not na(nyamHighLine)
        if na(nyamHighInvalidBar)
            if high > nyamHigh
                nyamHighInvalidBar := bar_index
            else
                line.set_x2(nyamHighLine, bar_index)
        else if bar_index <= nyamHighInvalidBar + sessionLineSnapBars
            line.set_x2(nyamHighLine, bar_index)
        else
            line.delete(nyamHighLine)
            nyamHighLine := na
    
    if not na(nyamLowLine)
        if na(nyamLowInvalidBar)
            if low < nyamLow
                nyamLowInvalidBar := bar_index
            else
                line.set_x2(nyamLowLine, bar_index)
        else if bar_index <= nyamLowInvalidBar + sessionLineSnapBars
            line.set_x2(nyamLowLine, bar_index)
        else
            line.delete(nyamLowLine)
            nyamLowLine := na
    
    // Lunch lines
    if not na(lunchHighLine)
        if na(lunchHighInvalidBar)
            if high > lunchHigh
                lunchHighInvalidBar := bar_index
            else
                line.set_x2(lunchHighLine, bar_index)
        else if bar_index <= lunchHighInvalidBar + sessionLineSnapBars
            line.set_x2(lunchHighLine, bar_index)
        else
            line.delete(lunchHighLine)
            lunchHighLine := na
    
    if not na(lunchLowLine)
        if na(lunchLowInvalidBar)
            if low < lunchLow
                lunchLowInvalidBar := bar_index
            else
                line.set_x2(lunchLowLine, bar_index)
        else if bar_index <= lunchLowInvalidBar + sessionLineSnapBars
            line.set_x2(lunchLowLine, bar_index)
        else
            line.delete(lunchLowLine)
            lunchLowLine := na
    
    // NY PM lines
    if not na(nypmHighLine)
        if na(nypmHighInvalidBar)
            if high > nypmHigh
                nypmHighInvalidBar := bar_index
            else
                line.set_x2(nypmHighLine, bar_index)
        else if bar_index <= nypmHighInvalidBar + sessionLineSnapBars
            line.set_x2(nypmHighLine, bar_index)
        else
            line.delete(nypmHighLine)
            nypmHighLine := na
    
    if not na(nypmLowLine)
        if na(nypmLowInvalidBar)
            if low < nypmLow
                nypmLowInvalidBar := bar_index
            else
                line.set_x2(nypmLowLine, bar_index)
        else if bar_index <= nypmLowInvalidBar + sessionLineSnapBars
            line.set_x2(nypmLowLine, bar_index)
        else
            line.delete(nypmLowLine)
            nypmLowLine := na

if array.size(bearSignalBars) > 0
    int keep = 0
    int newLen = 0
    for i = 0 to array.size(bearSignalBars)-1
        if not array.get(bearSignalFVGCreated, i)
            if i != keep
                array.set(bearSignalBars, keep, array.get(bearSignalBars, i))
                array.set(bearSignalReversalIds, keep, array.get(bearSignalReversalIds, i))
                array.set(bearSignalFVGCreated, keep, array.get(bearSignalFVGCreated, i))
            keep += 1
            newLen += 1
    while array.size(bearSignalBars) > newLen
        array.pop(bearSignalBars)
        array.pop(bearSignalReversalIds)
        array.pop(bearSignalFVGCreated)

if array.size(bullSignalBars) > 0
    int keep2 = 0
    int newLen2 = 0
    for i = 0 to array.size(bullSignalBars)-1
        if not array.get(bullSignalFVGCreated, i)
            if i != keep2
                array.set(bullSignalBars, keep2, array.get(bullSignalBars, i))
                array.set(bullSignalReversalIds, keep2, array.get(bullSignalReversalIds, i))
                array.set(bullSignalFVGCreated, keep2, array.get(bullSignalFVGCreated, i))
            keep2 += 1
            newLen2 += 1
    while array.size(bullSignalBars) > newLen2
        array.pop(bullSignalBars)
        array.pop(bullSignalReversalIds)
        array.pop(bullSignalFVGCreated)
// End of script
